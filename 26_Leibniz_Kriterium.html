<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Leibniz-Kriterium</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #e8daf0 0%, #d4cce0 100%);
            padding: 20px;
            min-height: 100vh;
        }
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 10px;
            font-size: 2.5em;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }
        .description {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 1.1em;
        }
        .theorem-box {
            background: #f0f9ff;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            border-left: 5px solid #2563eb;
        }
        .theorem-box h3 {
            margin-top: 0;
            color: #2563eb;
        }
        .condition {
            background: #f8f9fa;
            padding: 10px 15px;
            margin: 10px 0;
            border-radius: 5px;
            border-left: 3px solid #27ae60;
        }
        .condition.failed {
            border-left-color: #e74c3c;
        }
        .example-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin: 20px 0;
        }
        .example-btn {
            background: #2563eb;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            padding: 12px;
            font-size: 13px;
            transition: background 0.3s;
        }
        .example-btn:hover {
            background: #1e40af;
        }
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 30px;
            margin-bottom: 20px;
        }
        .control-group {
            display: flex;
            flex-direction: column;
        }
        label {
            margin-bottom: 10px;
            font-weight: bold;
            color: #34495e;
        }
        select {
            padding: 8px;
            border: 2px solid #2563eb;
            border-radius: 5px;
            font-size: 14px;
        }
        input[type="range"] {
            width: 100%;
            margin-top: 8px;
        }
        canvas {
            border: 2px solid #2563eb;
            border-radius: 5px;
            display: block;
            margin: 20px auto;
            background: white;
            max-width: 100%;
        }
        .canvas-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        .canvas-container {
            display: flex;
            flex-direction: column;
        }
        .canvas-title {
            font-weight: bold;
            color: #2563eb;
            margin-bottom: 10px;
            text-align: center;
        }
        .legend {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin: 15px 0;
            flex-wrap: wrap;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
        }
        .legend-box {
            width: 15px;
            height: 15px;
            border-radius: 3px;
        }
        .info {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        .info h3 {
            margin-top: 0;
            color: #2563eb;
        }
        .status-indicator {
            display: inline-block;
            padding: 5px 12px;
            border-radius: 5px;
            font-weight: bold;
            font-size: 14px;
        }
        .convergent {
            background: #d4edda;
            color: #155724;
        }
        .divergent {
            background: #f8d7da;
            color: #721c24;
        }
        .interpretation {
            background: #f8fafc;
            padding: 15px;
            border-left: 3px solid #e2e8f0;
            margin: 15px 0;
            border-radius: 3px;
        }
        .interpretation h3 {
            margin-top: 0;
            color: #64748b;
            font-size: 16px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Leibniz-Kriterium</h1>

        <div class="description">
            <p><strong>Leibniz-Kriterium für alternierende Reihen</strong></p>
            <p>Konvergenzbedingungen für Reihen der Form ∑(-1)<sup>n</sup>·a<sub>n</sub></p>
        </div>

        <div class="theorem-box">
            <h3>Satz von Leibniz</h3>
            <p>Eine alternierende Reihe <strong>∑(-1)<sup>n</sup>·a<sub>n</sub></strong> konvergiert, wenn:</p>
            <div class="condition" id="condition1">
                ✓ Die Folge (a<sub>n</sub>) ist <strong>monoton fallend</strong>: a<sub>n+1</sub> ≤ a<sub>n</sub>
            </div>
            <div class="condition" id="condition2">
                ✓ Die Folge ist eine <strong>Nullfolge</strong>: lim<sub>n→∞</sub> a<sub>n</sub> = 0
            </div>
            <p style="margin-top: 15px;"><strong>Fehlerabschätzung:</strong> |S - S<sub>n</sub>| ≤ a<sub>n+1</sub></p>
        </div>

        <div class="example-buttons">
            <button class="example-btn" onclick="loadExample('harmonic')">Alt. harmonische (1/n)</button>
            <button class="example-btn" onclick="loadExample('quadratic')">1/n²</button>
            <button class="example-btn" onclick="loadExample('cubic')">1/n³</button>
            <button class="example-btn" onclick="loadExample('exponential')">1/2ⁿ</button>
            <button class="example-btn" onclick="loadExample('sqrt')">1/√n</button>
            <button class="example-btn" onclick="loadExample('ln')">1/ln(n)</button>
        </div>

        <div class="controls">
            <div class="control-group">
                <label>Folge a<sub>n</sub></label>
                <select id="sequence">
                    <option value="harmonic">1/n (harmonisch)</option>
                    <option value="quadratic">1/n²</option>
                    <option value="cubic">1/n³</option>
                    <option value="exponential">1/2ⁿ</option>
                    <option value="sqrt">1/√n</option>
                    <option value="ln">1/ln(n+1)</option>
                    <option value="linear">1/(n+1) - oszillierend</option>
                </select>
            </div>

            <div class="control-group">
                <label>Anzahl Terme n: <span id="nValue">20</span></label>
                <input type="range" id="n" min="5" max="100" value="20">
            </div>
        </div>

        <div class="legend">
            <div class="legend-item">
                <div class="legend-box" style="background: #e74c3c;"></div>
                <span>Positive Terme (+a<sub>n</sub>)</span>
            </div>
            <div class="legend-item">
                <div class="legend-box" style="background: #3498db;"></div>
                <span>Negative Terme (-a<sub>n</sub>)</span>
            </div>
            <div class="legend-item">
                <div class="legend-box" style="background: #2563eb;"></div>
                <span>Partialsumme</span>
            </div>
            <div class="legend-item">
                <div class="legend-box" style="background: #27ae60; height: 3px;"></div>
                <span>Grenzwert</span>
            </div>
        </div>

        <div class="canvas-grid">
            <div class="canvas-container">
                <div class="canvas-title">Folge (a<sub>n</sub>) - Monotonie & Nullfolge</div>
                <canvas id="sequenceCanvas" width="550" height="400"></canvas>
            </div>
            <div class="canvas-container">
                <div class="canvas-title">Alternierende Reihe - Partialsummen</div>
                <canvas id="seriesCanvas" width="550" height="400"></canvas>
            </div>
        </div>

        <div class="info">
            <h3>Konvergenzanalyse</h3>
            <div id="analysisContent"></div>
        </div>

        <div class="interpretation">
            <h3>Interpretation</h3>
            <p id="interpretation">
                Wähle eine Folge und beobachte, ob die Bedingungen des Leibniz-Kriteriums erfüllt sind.
            </p>
        </div>

        <div style="text-align: center; margin-top: 30px;">
            <a href="index.html" style="color: #3498db; text-decoration: none; font-weight: 500;">← Zurück zur Übersicht</a>
        </div>
    </div>

    <script>
        const sequenceCanvas = document.getElementById('sequenceCanvas');
        const seqCtx = sequenceCanvas.getContext('2d');
        const seriesCanvas = document.getElementById('seriesCanvas');
        const serCtx = seriesCanvas.getContext('2d');

        const sequenceSelect = document.getElementById('sequence');
        const nSlider = document.getElementById('n');
        const nValue = document.getElementById('nValue');

        const sequences = {
            harmonic: {
                name: '1/n',
                term: (n) => 1 / n,
                limit: Math.log(2),
                monotone: true,
                nullSequence: true
            },
            quadratic: {
                name: '1/n²',
                term: (n) => 1 / (n * n),
                limit: Math.PI * Math.PI / 12,
                monotone: true,
                nullSequence: true
            },
            cubic: {
                name: '1/n³',
                term: (n) => 1 / (n * n * n),
                limit: 0.9015, // ≈ -3ζ(3)/4 (numerische Approximation)
                monotone: true,
                nullSequence: true
            },
            exponential: {
                name: '1/2ⁿ',
                term: (n) => 1 / Math.pow(2, n),
                limit: 1/3,
                monotone: true,
                nullSequence: true
            },
            sqrt: {
                name: '1/√n',
                term: (n) => 1 / Math.sqrt(n),
                limit: -0.6048948, // Numerische Approximation (konvergiert langsam)
                monotone: true,
                nullSequence: true
            },
            ln: {
                name: '1/ln(n+1)',
                term: (n) => n === 0 ? 1 : 1 / Math.log(n + 1),
                limit: -0.9242, // Numerische Approximation
                monotone: true,
                nullSequence: true
            },
            linear: {
                name: '(-1)ⁿ/(n+1)',
                term: (n) => 1 / (n + 1),
                limit: Math.log(2),
                monotone: true,
                nullSequence: true
            }
        };

        function alternatingSeries(seq, n) {
            let sum = 0;
            for (let i = 1; i <= n; i++) {
                sum += Math.pow(-1, i) * seq.term(i);
            }
            return sum;
        }

        function isMonotone(seq, n) {
            for (let i = 1; i < n; i++) {
                if (seq.term(i + 1) > seq.term(i)) {
                    return false;
                }
            }
            return true;
        }

        function isNullSequence(seq, n) {
            const lastTerm = seq.term(n);
            return lastTerm < 0.1;
        }

        function toCanvasX(x, xMax, canvas) {
            const padding = 60;
            const width = canvas.width - 2 * padding;
            return padding + (x / xMax) * width;
        }

        function toCanvasY(y, yMin, yMax, canvas) {
            const paddingTop = 40;
            const paddingBottom = 50;
            const height = canvas.height - paddingTop - paddingBottom;
            return canvas.height - paddingBottom - (y - yMin) / (yMax - yMin) * height;
        }

        function drawAxes(ctx, xMax, yMin, yMax) {
            const canvas = ctx.canvas;
            ctx.strokeStyle = '#2c3e50';
            ctx.lineWidth = 2;

            // X-Achse
            ctx.beginPath();
            ctx.moveTo(toCanvasX(0, xMax, canvas), toCanvasY(0, yMin, yMax, canvas));
            ctx.lineTo(toCanvasX(xMax, xMax, canvas), toCanvasY(0, yMin, yMax, canvas));
            ctx.stroke();

            // Y-Achse
            ctx.beginPath();
            ctx.moveTo(toCanvasX(0, xMax, canvas), toCanvasY(yMin, yMin, yMax, canvas));
            ctx.lineTo(toCanvasX(0, xMax, canvas), toCanvasY(yMax, yMin, yMax, canvas));
            ctx.stroke();

            // Labels
            ctx.fillStyle = '#2c3e50';
            ctx.font = '12px Arial';
            ctx.fillText('n', toCanvasX(xMax, xMax, canvas) + 10, toCanvasY(0, yMin, yMax, canvas) + 5);
        }

        function drawSequence(seq, n) {
            seqCtx.clearRect(0, 0, sequenceCanvas.width, sequenceCanvas.height);

            let yMax = seq.term(1);
            let yMin = 0;
            for (let i = 1; i <= n; i++) {
                yMax = Math.max(yMax, seq.term(i));
            }
            yMax = yMax * 1.2;

            drawAxes(seqCtx, n, yMin, yMax);

            // Zeichne Folge als Punkte mit Verbindung
            seqCtx.strokeStyle = '#9b59b6';
            seqCtx.lineWidth = 2;
            seqCtx.beginPath();

            for (let i = 1; i <= n; i++) {
                const x = toCanvasX(i, n, sequenceCanvas);
                const y = toCanvasY(seq.term(i), yMin, yMax, sequenceCanvas);

                if (i === 1) {
                    seqCtx.moveTo(x, y);
                } else {
                    seqCtx.lineTo(x, y);
                }
            }
            seqCtx.stroke();

            // Punkte
            for (let i = 1; i <= n; i++) {
                const x = toCanvasX(i, n, sequenceCanvas);
                const y = toCanvasY(seq.term(i), yMin, yMax, sequenceCanvas);

                seqCtx.fillStyle = '#9b59b6';
                seqCtx.beginPath();
                seqCtx.arc(x, y, 4, 0, 2 * Math.PI);
                seqCtx.fill();
            }

            // Nulllinie
            if (yMin === 0) {
                seqCtx.strokeStyle = '#27ae60';
                seqCtx.lineWidth = 2;
                seqCtx.setLineDash([5, 5]);
                seqCtx.beginPath();
                seqCtx.moveTo(toCanvasX(0, n, sequenceCanvas), toCanvasY(0, yMin, yMax, sequenceCanvas));
                seqCtx.lineTo(toCanvasX(n, n, sequenceCanvas), toCanvasY(0, yMin, yMax, sequenceCanvas));
                seqCtx.stroke();
                seqCtx.setLineDash([]);
            }
        }

        function drawSeries(seq, n) {
            serCtx.clearRect(0, 0, seriesCanvas.width, seriesCanvas.height);

            // Berechne y-Bereich
            let yMax = 0;
            let yMin = 0;
            for (let i = 1; i <= n; i++) {
                const sum = alternatingSeries(seq, i);
                yMax = Math.max(yMax, sum);
                yMin = Math.min(yMin, sum);
            }
            const margin = Math.max(Math.abs(yMax), Math.abs(yMin)) * 0.2;
            yMax += margin;
            yMin -= margin;

            drawAxes(serCtx, n, yMin, yMax);

            // Einzelne Terme als Balken
            for (let i = 1; i <= n; i++) {
                const term = Math.pow(-1, i) * seq.term(i);
                const x = toCanvasX(i, n, seriesCanvas);
                const y0 = toCanvasY(0, yMin, yMax, seriesCanvas);
                const y1 = toCanvasY(term, yMin, yMax, seriesCanvas);

                const barWidth = Math.min(10, (seriesCanvas.width - 120) / n * 0.5);

                if (term > 0) {
                    serCtx.fillStyle = 'rgba(231, 76, 60, 0.5)';
                } else {
                    serCtx.fillStyle = 'rgba(52, 152, 219, 0.5)';
                }

                serCtx.fillRect(x - barWidth/2, Math.min(y0, y1), barWidth, Math.abs(y1 - y0));
            }

            // Partialsummen
            serCtx.strokeStyle = '#2563eb';
            serCtx.lineWidth = 2.5;
            serCtx.beginPath();

            for (let i = 1; i <= n; i++) {
                const sum = alternatingSeries(seq, i);
                const x = toCanvasX(i, n, seriesCanvas);
                const y = toCanvasY(sum, yMin, yMax, seriesCanvas);

                if (i === 1) {
                    serCtx.moveTo(x, y);
                } else {
                    serCtx.lineTo(x, y);
                }

                // Punkte
                serCtx.fillStyle = '#2563eb';
                serCtx.beginPath();
                serCtx.arc(x, y, 4, 0, 2 * Math.PI);
                serCtx.fill();
                serCtx.beginPath();
                serCtx.moveTo(x, y);
            }
            serCtx.stroke();

            // Grenzwert
            if (seq.limit !== null) {
                const limitY = toCanvasY(seq.limit, yMin, yMax, seriesCanvas);

                serCtx.strokeStyle = '#27ae60';
                serCtx.lineWidth = 3;
                serCtx.setLineDash([8, 4]);
                serCtx.beginPath();
                serCtx.moveTo(toCanvasX(0, n, seriesCanvas), limitY);
                serCtx.lineTo(toCanvasX(n, n, seriesCanvas), limitY);
                serCtx.stroke();
                serCtx.setLineDash([]);

                // Label mit Hintergrund
                const labelText = `S = ${seq.limit.toFixed(4)}`;
                serCtx.font = 'bold 13px Arial';
                const textWidth = serCtx.measureText(labelText).width;
                const labelX = toCanvasX(n, n, seriesCanvas) - textWidth - 20;
                const labelY = limitY - 10;

                // Weißer Hintergrund für bessere Lesbarkeit
                serCtx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                serCtx.fillRect(labelX - 5, labelY - 15, textWidth + 10, 22);

                // Text
                serCtx.fillStyle = '#27ae60';
                serCtx.fillText(labelText, labelX, labelY);
            }
        }

        function updateAnalysis(seq, n) {
            const monotone = isMonotone(seq, n);
            const nullSeq = isNullSequence(seq, n);
            const converges = monotone && nullSeq;

            const condition1 = document.getElementById('condition1');
            const condition2 = document.getElementById('condition2');

            if (monotone) {
                condition1.classList.remove('failed');
                condition1.innerHTML = '✓ Die Folge (a<sub>n</sub>) ist <strong>monoton fallend</strong>: a<sub>n+1</sub> ≤ a<sub>n</sub>';
            } else {
                condition1.classList.add('failed');
                condition1.innerHTML = '✗ Die Folge (a<sub>n</sub>) ist <strong>NICHT monoton fallend</strong>';
            }

            if (nullSeq) {
                condition2.classList.remove('failed');
                condition2.innerHTML = '✓ Die Folge ist eine <strong>Nullfolge</strong>: lim<sub>n→∞</sub> a<sub>n</sub> = 0';
            } else {
                condition2.classList.add('failed');
                condition2.innerHTML = '✗ Die Folge ist <strong>KEINE Nullfolge</strong>';
            }

            const analysisContent = document.getElementById('analysisContent');
            let html = '';

            html += `<p><strong>Folge:</strong> a<sub>n</sub> = ${seq.name}</p>`;
            html += `<p><strong>Alternierende Reihe:</strong> ∑(-1)<sup>n</sup>·${seq.name}</p>`;
            html += `<p><strong>Monotonie:</strong> <span class="status-indicator ${monotone ? 'convergent' : 'divergent'}">${monotone ? 'Erfüllt ✓' : 'Nicht erfüllt ✗'}</span></p>`;
            html += `<p><strong>Nullfolge:</strong> <span class="status-indicator ${nullSeq ? 'convergent' : 'divergent'}">${nullSeq ? 'Erfüllt ✓' : 'Nicht erfüllt ✗'}</span></p>`;
            html += `<p><strong>Konvergenz:</strong> <span class="status-indicator ${converges ? 'convergent' : 'divergent'}">${converges ? 'Konvergent' : 'Unbestimmt'}</span></p>`;

            if (seq.limit !== null) {
                html += `<p><strong>Grenzwert:</strong> ${seq.limit.toFixed(6)}</p>`;
            }

            const lastSum = alternatingSeries(seq, n);
            html += `<p><strong>Partialsumme S<sub>${n}</sub>:</strong> ${lastSum.toFixed(6)}</p>`;

            if (converges && seq.limit !== null) {
                const error = Math.abs(seq.limit - lastSum);
                const errorBound = seq.term(n + 1);
                html += `<p><strong>Fehler:</strong> |S - S<sub>${n}</sub>| = ${error.toFixed(6)} ≤ a<sub>${n+1}</sub> = ${errorBound.toFixed(6)}</p>`;
            }

            analysisContent.innerHTML = html;
        }

        function updateInterpretation(seq, n) {
            const monotone = isMonotone(seq, n);
            const nullSeq = isNullSequence(seq, n);
            const converges = monotone && nullSeq;

            const interp = document.getElementById('interpretation');
            let text = `<strong>Folge a<sub>n</sub> = ${seq.name}:</strong><br><br>`;

            if (converges) {
                text += `Beide Bedingungen des Leibniz-Kriteriums sind erfüllt:<br>`;
                text += `• Die Folge ist monoton fallend<br>`;
                text += `• Die Folge konvergiert gegen 0<br><br>`;
                text += `Daher <strong>konvergiert</strong> die alternierende Reihe ∑(-1)<sup>n</sup>·${seq.name}.`;
                if (seq.limit !== null) {
                    text += `<br><br>Der Grenzwert ist ${seq.limit.toFixed(4)}.`;
                }
            } else {
                text += `Das Leibniz-Kriterium kann nicht angewendet werden:<br>`;
                if (!monotone) {
                    text += `• Die Folge ist nicht monoton fallend<br>`;
                }
                if (!nullSeq) {
                    text += `• Die Folge konvergiert nicht gegen 0<br>`;
                }
                text += `<br>Die Konvergenz ist mit diesem Kriterium nicht nachweisbar.`;
            }

            interp.innerHTML = text;
        }

        function draw() {
            const seqKey = sequenceSelect.value;
            const seq = sequences[seqKey];
            const n = parseInt(nSlider.value);

            nValue.textContent = n;

            drawSequence(seq, n);
            drawSeries(seq, n);
            updateAnalysis(seq, n);
            updateInterpretation(seq, n);
        }

        function loadExample(type) {
            sequenceSelect.value = type;
            nSlider.value = 20;
            draw();
        }

        sequenceSelect.addEventListener('change', draw);
        nSlider.addEventListener('input', draw);

        draw();
    </script>
</body>
</html>
