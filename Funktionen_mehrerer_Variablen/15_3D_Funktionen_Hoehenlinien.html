<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D-Funktionen und Höhenlinien</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #daf0e8 0%, #bcd8d4 100%);
            padding: 20px;
            min-height: 100vh;
        }
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 10px;
            font-size: 2.5em;
        }
        .container {
            max-width: 1000px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 30px;
            margin-bottom: 20px;
        }
        .control-group {
            display: flex;
            flex-direction: column;
        }
        label {
            margin-bottom: 10px;
            font-weight: bold;
            color: #34495e;
        }
        select, input {
            padding: 8px;
            border: 2px solid #2563eb;
            border-radius: 5px;
            font-size: 14px;
        }
        input[type="range"] {
            width: 100%;
            margin-top: 8px;
            padding: 0;
        }
        .canvas-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        .canvas-wrapper {
            text-align: center;
        }
        .canvas-title {
            font-weight: bold;
            color: #2563eb;
            margin-bottom: 10px;
            font-size: 16px;
        }
        canvas {
            border: 2px solid #2563eb;
            border-radius: 5px;
            width: 100%;
            background: white;
        }
        .description {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 1.1em;
        }
        .example-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 10px;
            margin: 20px 0;
        }
        .example-btn {
            background: #2563eb;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            padding: 12px;
            font-size: 13px;
            transition: background 0.3s;
        }
        .example-btn:hover {
            background: #1e40af;
        }
        .info {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        .info p {
            margin: 8px 0;
        }
        .interpretation {
            background: #f8fafc;
            padding: 15px;
            border-left: 3px solid #e2e8f0;
            margin: 15px 0;
            border-radius: 3px;
        }
        .interpretation h3 {
            margin-top: 0;
            color: #64748b;
            font-size: 16px;
        }
        .legend {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin: 15px 0;
            flex-wrap: wrap;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
        }
        .legend-box {
            width: 15px;
            height: 15px;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>3D-Funktionen und Höhenlinien</h1>

        <div class="description">
            <p><strong>Funktion mit zwei Variablen:</strong> z = f(x, y)</p>
            <p><strong>Höhenlinien (Niveaulinien):</strong> Kurven mit konstantem Funktionswert f(x, y) = c</p>
            <p><strong>Vergleich:</strong> Wie eine Landkarte - Höhenlinien verbinden Punkte gleicher Höhe</p>
        </div>

        <div class="example-buttons">
            <button class="example-btn" onclick="loadExample('paraboloid')">Paraboloid</button>
            <button class="example-btn" onclick="loadExample('saddle')">Sattel</button>
            <button class="example-btn" onclick="loadExample('cone')">Kegel</button>
            <button class="example-btn" onclick="loadExample('waves')">Wellen</button>
            <button class="example-btn" onclick="loadExample('gaussian')">Gauß-Glocke</button>
        </div>

        <div class="controls">
            <div class="control-group">
                <label>Funktion z = f(x, y)</label>
                <select id="function">
                    <option value="paraboloid">f(x,y) = x² + y² (Paraboloid)</option>
                    <option value="saddle">f(x,y) = x² - y² (Sattelfläche)</option>
                    <option value="cone">f(x,y) = √(x² + y²) (Kegel)</option>
                    <option value="waves">f(x,y) = sin(x)·cos(y) (Wellen)</option>
                    <option value="gaussian">f(x,y) = e^(-(x²+y²)) (Gauß)</option>
                    <option value="plane">f(x,y) = x + y (Ebene)</option>
                </select>
            </div>

            <div class="control-group">
                <label>Anzahl Höhenlinien: <span id="nContours">10</span></label>
                <input type="range" id="contours" min="5" max="20" value="10">
            </div>

            <div class="control-group">
                <label>Rotation (3D): <span id="angleValue">30</span>°</label>
                <input type="range" id="angle" min="0" max="360" value="30">
            </div>
        </div>

        <div class="legend">
            <div class="legend-item">
                <div class="legend-box" style="background: linear-gradient(to right, blue, cyan, green, yellow, red);"></div>
                <span>Farbkodierung: niedrig → hoch</span>
            </div>
        </div>

        <div class="canvas-grid">
            <div class="canvas-wrapper">
                <div class="canvas-title">3D-Ansicht (perspektivisch)</div>
                <canvas id="canvas3D" width="600" height="600"></canvas>
                <p style="color: #7f8c8d; font-size: 13px; margin-top: 5px;">
                    Drahtgittermodell der Funktion z = f(x,y)
                </p>
            </div>

            <div class="canvas-wrapper">
                <div class="canvas-title">Höhenlinien (Draufsicht)</div>
                <canvas id="canvasContour" width="600" height="600"></canvas>
                <p style="color: #7f8c8d; font-size: 13px; margin-top: 5px;">
                    Kurven mit f(x,y) = konstant
                </p>
            </div>
        </div>

        <div class="info">
            <p><strong>Funktion:</strong> <span id="funcInfo">z = f(x, y)</span></p>
            <p><strong>Definitionsbereich:</strong> x, y ∈ [-3, 3]</p>
            <p><strong>Wertebereich:</strong> z ∈ [<span id="minZ">0</span>, <span id="maxZ">0</span>]</p>
        </div>

        <div class="interpretation">
            <h3>Interpretation</h3>
            <p id="interpretation">
                Wähle eine Funktion und beobachte den Zusammenhang zwischen 3D-Fläche und Höhenlinien.
            </p>
        </div>
    
        <div style="text-align: center; margin-top: 30px;">
            <a href="index.html" style="color: #3498db; text-decoration: none; font-weight: 500;">← Zurück zur Übersicht</a>
        </div>
    </div>

    <script>
        const canvas3D = document.getElementById('canvas3D');
        const canvasContour = document.getElementById('canvasContour');
        const ctx3D = canvas3D.getContext('2d');
        const ctxContour = canvasContour.getContext('2d');

        const functionSelect = document.getElementById('function');
        const contoursSlider = document.getElementById('contours');
        const angleSlider = document.getElementById('angle');

        // Mouse interaction state
        let hoverPoint = null;

        const functions = {
            paraboloid: {
                f: (x, y) => x * x + y * y,
                name: 'z = x² + y²',
                description: 'Paraboloid: Rotationsfläche. Höhenlinien sind konzentrische Kreise. Minimum bei (0,0).'
            },
            saddle: {
                f: (x, y) => x * x - y * y,
                name: 'z = x² - y²',
                description: 'Sattelpunkt: Hyperbolisches Paraboloid. Höhenlinien sind Hyperbeln. Sattelpunkt bei (0,0).'
            },
            cone: {
                f: (x, y) => Math.sqrt(x * x + y * y),
                name: 'z = √(x² + y²)',
                description: 'Kegel: Spitze bei (0,0). Höhenlinien sind konzentrische Kreise mit gleichem Abstand.'
            },
            waves: {
                f: (x, y) => Math.sin(x) * Math.cos(y),
                name: 'z = sin(x)·cos(y)',
                description: 'Wellenfunktion: Periodisches Auf und Ab. Höhenlinien zeigen Wellenmuster.'
            },
            gaussian: {
                f: (x, y) => Math.exp(-(x * x + y * y)),
                name: 'z = e^(-(x²+y²))',
                description: 'Gauß-Glocke: Maximum bei (0,0). Höhenlinien sind konzentrische Kreise mit exponentiell abnehmendem Abstand.'
            },
            plane: {
                f: (x, y) => x + y,
                name: 'z = x + y',
                description: 'Ebene: Einfachste Fläche. Höhenlinien sind parallele Geraden.'
            }
        };

        function getColor(value, min, max) {
            const normalized = (value - min) / (max - min);

            // Blau -> Cyan -> Grün -> Gelb -> Rot
            if (normalized < 0.25) {
                const t = normalized / 0.25;
                return `rgb(${Math.floor(t * 255)}, ${Math.floor(t * 255)}, 255)`;
            } else if (normalized < 0.5) {
                const t = (normalized - 0.25) / 0.25;
                return `rgb(0, 255, ${Math.floor(255 * (1 - t))})`;
            } else if (normalized < 0.75) {
                const t = (normalized - 0.5) / 0.25;
                return `rgb(${Math.floor(t * 255)}, 255, 0)`;
            } else {
                const t = (normalized - 0.75) / 0.25;
                return `rgb(255, ${Math.floor(255 * (1 - t))}, 0)`;
            }
        }

        function draw3D(func, angle) {
            ctx3D.clearRect(0, 0, canvas3D.width, canvas3D.height);

            const angleRad = (angle * Math.PI) / 180;
            const resolution = 30;
            const range = 3;

            // Berechne Min/Max für Farbskalierung
            let minZ = Infinity;
            let maxZ = -Infinity;

            for (let i = 0; i <= resolution; i++) {
                for (let j = 0; j <= resolution; j++) {
                    const x = -range + (2 * range * i) / resolution;
                    const y = -range + (2 * range * j) / resolution;
                    const z = func(x, y);
                    if (isFinite(z)) {
                        minZ = Math.min(minZ, z);
                        maxZ = Math.max(maxZ, z);
                    }
                }
            }

            document.getElementById('minZ').textContent = minZ.toFixed(2);
            document.getElementById('maxZ').textContent = maxZ.toFixed(2);

            // 3D zu 2D Projektion (isometrisch)
            function project(x, y, z) {
                const scale = 80;
                const centerX = canvas3D.width / 2;
                const centerY = canvas3D.height / 2 + 50;

                // Rotation um vertikale Achse
                const xRot = x * Math.cos(angleRad) - y * Math.sin(angleRad);
                const yRot = x * Math.sin(angleRad) + y * Math.cos(angleRad);

                // Isometrische Projektion
                const screenX = centerX + scale * xRot;
                const screenY = centerY - scale * (z * 0.7 + yRot * 0.5);

                return [screenX, screenY];
            }

            // Zeichne Drahtgitter
            for (let i = 0; i < resolution; i++) {
                for (let j = 0; j < resolution; j++) {
                    const x1 = -range + (2 * range * i) / resolution;
                    const y1 = -range + (2 * range * j) / resolution;
                    const x2 = -range + (2 * range * (i + 1)) / resolution;
                    const y2 = -range + (2 * range * (j + 1)) / resolution;

                    const z1 = func(x1, y1);
                    const z2 = func(x2, y1);
                    const z3 = func(x1, y2);

                    if (isFinite(z1) && isFinite(z2) && isFinite(z3)) {
                        const [sx1, sy1] = project(x1, y1, z1);
                        const [sx2, sy2] = project(x2, y1, z2);
                        const [sx3, sy3] = project(x1, y2, z3);

                        const color = getColor(z1, minZ, maxZ);

                        // Horizontale Linie
                        ctx3D.strokeStyle = color;
                        ctx3D.lineWidth = 1;
                        ctx3D.beginPath();
                        ctx3D.moveTo(sx1, sy1);
                        ctx3D.lineTo(sx2, sy2);
                        ctx3D.stroke();

                        // Vertikale Linie
                        ctx3D.beginPath();
                        ctx3D.moveTo(sx1, sy1);
                        ctx3D.lineTo(sx3, sy3);
                        ctx3D.stroke();
                    }
                }
            }

            // Achsen
            ctx3D.strokeStyle = '#2c3e50';
            ctx3D.lineWidth = 2;
            const [ox, oy] = project(0, 0, 0);
            const [xx, xy] = project(range, 0, 0);
            const [yx, yy] = project(0, range, 0);
            const [zx, zy] = project(0, 0, maxZ);

            ctx3D.beginPath();
            ctx3D.moveTo(ox, oy);
            ctx3D.lineTo(xx, xy);
            ctx3D.stroke();

            ctx3D.beginPath();
            ctx3D.moveTo(ox, oy);
            ctx3D.lineTo(yx, yy);
            ctx3D.stroke();

            ctx3D.beginPath();
            ctx3D.moveTo(ox, oy);
            ctx3D.lineTo(zx, zy);
            ctx3D.stroke();

            // Labels
            ctx3D.fillStyle = '#2c3e50';
            ctx3D.font = 'bold 14px Arial';
            ctx3D.fillText('x', xx + 10, xy);
            ctx3D.fillText('y', yx + 10, yy);
            ctx3D.fillText('z', zx, zy - 10);
        }

        function drawContours(func, nContours) {
            ctxContour.clearRect(0, 0, canvasContour.width, canvasContour.height);

            const range = 3;
            const resolution = 200;

            // Berechne Min/Max
            let minZ = Infinity;
            let maxZ = -Infinity;

            for (let i = 0; i <= resolution; i++) {
                for (let j = 0; j <= resolution; j++) {
                    const x = -range + (2 * range * i) / resolution;
                    const y = -range + (2 * range * j) / resolution;
                    const z = func(x, y);
                    if (isFinite(z)) {
                        minZ = Math.min(minZ, z);
                        maxZ = Math.max(maxZ, z);
                    }
                }
            }

            function toCanvasX(x) {
                const padding = 50;
                return padding + ((x + range) / (2 * range)) * (canvasContour.width - 2 * padding);
            }

            function toCanvasY(y) {
                const padding = 50;
                return canvasContour.height - padding - ((y + range) / (2 * range)) * (canvasContour.height - 2 * padding);
            }

            // Grid
            ctxContour.strokeStyle = '#ecf0f1';
            ctxContour.lineWidth = 1;
            for (let i = -range; i <= range; i++) {
                ctxContour.beginPath();
                ctxContour.moveTo(toCanvasX(i), toCanvasY(-range));
                ctxContour.lineTo(toCanvasX(i), toCanvasY(range));
                ctxContour.stroke();

                ctxContour.beginPath();
                ctxContour.moveTo(toCanvasX(-range), toCanvasY(i));
                ctxContour.lineTo(toCanvasX(range), toCanvasY(i));
                ctxContour.stroke();
            }

            // Achsen
            ctxContour.strokeStyle = '#2c3e50';
            ctxContour.lineWidth = 2;
            ctxContour.beginPath();
            ctxContour.moveTo(toCanvasX(-range), toCanvasY(0));
            ctxContour.lineTo(toCanvasX(range), toCanvasY(0));
            ctxContour.stroke();

            ctxContour.beginPath();
            ctxContour.moveTo(toCanvasX(0), toCanvasY(-range));
            ctxContour.lineTo(toCanvasX(0), toCanvasY(range));
            ctxContour.stroke();

            // Zeichne Höhenlinien
            for (let c = 0; c < nContours; c++) {
                const level = minZ + (c / (nContours - 1)) * (maxZ - minZ);
                const color = getColor(level, minZ, maxZ);

                ctxContour.strokeStyle = color;
                ctxContour.lineWidth = 2;

                // Marching squares algorithm (vereinfacht)
                for (let i = 0; i < resolution; i++) {
                    for (let j = 0; j < resolution; j++) {
                        const x1 = -range + (2 * range * i) / resolution;
                        const y1 = -range + (2 * range * j) / resolution;
                        const x2 = -range + (2 * range * (i + 1)) / resolution;
                        const y2 = -range + (2 * range * (j + 1)) / resolution;

                        const z11 = func(x1, y1);
                        const z12 = func(x1, y2);
                        const z21 = func(x2, y1);
                        const z22 = func(x2, y2);

                        if (isFinite(z11) && isFinite(z12) && isFinite(z21) && isFinite(z22)) {
                            // Prüfe ob Konturlinie durch Zelle geht
                            if ((z11 <= level && level <= z22) || (z22 <= level && level <= z11) ||
                                (z12 <= level && level <= z21) || (z21 <= level && level <= z12)) {
                                const xc = (x1 + x2) / 2;
                                const yc = (y1 + y2) / 2;
                                const zc = func(xc, yc);

                                if (Math.abs(zc - level) < 0.1) {
                                    ctxContour.fillStyle = color;
                                    ctxContour.fillRect(toCanvasX(xc) - 1, toCanvasY(yc) - 1, 2, 2);
                                }
                            }
                        }
                    }
                }
            }

            // Labels
            ctxContour.fillStyle = '#2c3e50';
            ctxContour.font = '14px Arial';
            ctxContour.fillText('x', toCanvasX(range) + 10, toCanvasY(0) + 5);
            ctxContour.fillText('y', toCanvasX(0) + 10, toCanvasY(range) - 10);
        }

        function draw() {
            const funcKey = functionSelect.value;
            const funcData = functions[funcKey];
            const nContours = parseInt(contoursSlider.value);
            const angle = parseFloat(angleSlider.value);

            document.getElementById('nContours').textContent = nContours;
            document.getElementById('angleValue').textContent = angle.toFixed(0);

            draw3D(funcData.f, angle);
            drawContours(funcData.f, nContours);

            // Update Info
            document.getElementById('funcInfo').textContent = funcData.name;

            // Interpretation
            const interp = document.getElementById('interpretation');
            let text = `<strong>${funcData.name}:</strong> ${funcData.description}<br><br>`;
            text += `<strong>Links:</strong> 3D-Drahtgittermodell zeigt die Fläche im Raum. Farben kodieren die Höhe.<br>`;
            text += `<strong>Rechts:</strong> Höhenlinien (Draufsicht) zeigen Kurven mit gleicher Höhe - wie bei einer topografischen Karte.`;

            interp.innerHTML = text;
        }

        function loadExample(type) {
            functionSelect.value = type;
            contoursSlider.value = 10;
            angleSlider.value = 30;
            draw();
        }

        functionSelect.addEventListener('change', draw);
        contoursSlider.addEventListener('input', draw);
        angleSlider.addEventListener('input', draw);

        draw();
    </script>
</body>
</html>
